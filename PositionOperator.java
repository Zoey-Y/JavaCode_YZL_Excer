public class PositionOperator{
	public static void main(String[] args){
		/*
		注:一、计算机的所有计算都以补码形式计算
		   二、计算机计算的结果是以原码的形式呈现
			1.首先将2的原码转换为补码――>2:00000000 00000000 00000000 00000010
 			2.其次将4的原码转换为补码――>4:00000000 00000000 00000000 00000100
			3.按位与(&)的计算:
		
		&:运算一假则假
			2:00000000 00000000 00000000 00000010
			4:00000000 00000000 00000000 00000100
	  上下对比:00000000 00000000 00000000 00000000
		*/
		//所以结果为0
		System.out.println(2 & 4);//这里是2和4都为整型原码





		/*
		负数原、反、补运算原则:
			1.首先-2的原码转换为补码(此为负数,所以要原反补进行相互转换)
			-2(原):100000000 00000000 00000000 00000010
			-2(反):111111111 11111111 11111111 11111101(符号位外其他位取反)
			-2(补):111111111 11111111 11111111 11111110(反码+1得补码)
		按位取反(~)计算:
		~:运算补码符号位全部取反
			  -2(补):11111111 11111111 11111111 11111110
			-2(取反):00000000 00000000 00000000 00000001
			最后显示结果:由于首位为0(正数),所以直接取值
		*/
		//所以答案为1
		System.out.println(~-2);
		/*
			推到按位取反(~)的例子:
			2:00000000 00000000 00000000 00000010
		 2(~):11111111 11111111 11111111 11111101
		 此时按位取反之后得的是负数补码,要补――>反――>原
		 2(~):11111111 11111111 11111111 11111101
		 2(反):11111111 11111111 11111111 11111100(补码-1)
		 2(原):10000000 00000000 00000000 00000011(符号位不变其它取反)
		 最终得-3
		*/
		System.out.println(~2);//结果:-3
		/*
		    3(原码):00000000 00000000 00000000 0000011
			2(原码):00000000 00000000 00000000 0000010(其为正数所以补码与原码相同)
			2(补码):00000000 00000000 00000000 0000010
			3(补码):00000000 00000000 00000000 0000011
		或(|)运算:一真则真
		    2(补码):00000000 00000000 00000000 0000010
			3(补码):00000000 00000000 00000000 0000011
			(2 | 3):00000000 00000000 00000000 0000011(正数)
			最终结果:3			
		*/
		System.out.println(2 | 3);//3

		/*
			 2(原补):00000000 00000000 00000000 0000010
			-3(原码):10000000 00000000 00000000 0000011
			-3(反码):11111111 11111111 11111111 1111100
			-3(补码):11111111 11111111 11111111 1111101
			   2(补):00000000 00000000 00000000 0000010
		异或(^)运算:相同为假,不同为真
			-3(补码):11111111 11111111 11111111 1111101
			   2(补):00000000 00000000 00000000 0000010
			(-3 ^ 2):11111111 11111111 11111111 1111111(此为负补得转换成原码)
			    (反):11111111 11111111 11111111 1111110(补转反-1)
			    (原):10000000 00000000 00000000 0000001(反转原符号位不变其它位取反)
			    最终结果:-1
		*/
		System.out.println(-3 ^ 2);//-1
	}
}